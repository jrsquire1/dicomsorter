<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DICOM File Organizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c5aa0;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 16px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .upload-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .drop-zone {
            border: 3px dashed #cbd5e0;
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            background: #f8fafc;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .drop-zone.dragover {
            border-color: #2c5aa0;
            background: #ebf4ff;
        }

        .drop-zone.processing {
            border-color: #f6ad55;
            background: #fffaf0;
        }

        .drop-zone.error {
            border-color: #fc8181;
            background: #fed7d7;
        }

        .drop-icon {
            font-size: 48px;
            margin-bottom: 20px;
            color: #a0aec0;
        }

        .drop-zone h3 {
            margin-bottom: 10px;
            color: #2d3748;
        }

        .drop-zone p {
            color: #718096;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .browse-btn {
            background: #2c5aa0;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .browse-btn:hover {
            background: #2a5298;
        }

        .validation-info {
            background: #e6fffa;
            border: 1px solid #38b2ac;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 14px;
        }

        .validation-info h4 {
            color: #234e52;
            margin-bottom: 8px;
        }

        .validation-info ul {
            color: #285e61;
            margin-left: 20px;
        }

        .hierarchy-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .hierarchy-title {
            margin-bottom: 20px;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hierarchy-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #2c5aa0;
        }

        .stat-label {
            font-size: 12px;
            color: #718096;
            margin-top: 5px;
        }

        .hierarchy-tree {
            border-left: 2px solid #e2e8f0;
            padding-left: 20px;
        }

        .tree-level {
            margin-bottom: 15px;
            position: relative;
        }

        .tree-level::before {
            content: '';
            position: absolute;
            left: -22px;
            top: 15px;
            width: 20px;
            height: 1px;
            background: #e2e8f0;
        }

        .tree-node {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .tree-node.has-files {
            border-color: #68d391;
            background: #f0fff4;
        }

        .tree-node.expandable {
            cursor: pointer;
        }

        .tree-node.expandable:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .node-title {
            font-weight: 600;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .expand-icon {
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .expand-icon.expanded {
            transform: rotate(90deg);
        }

        .file-count {
            background: #2c5aa0;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .node-details {
            font-size: 14px;
            color: #718096;
            margin-bottom: 10px;
        }

        .metadata-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        .metadata-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 8px;
        }

        .metadata-label {
            font-weight: 600;
            color: #4a5568;
        }

        .metadata-value {
            color: #718096;
            word-break: break-all;
        }

        .file-list {
            list-style: none;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 5px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .file-item:hover {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .file-name {
            font-weight: 500;
            color: #2d3748;
        }

        .file-meta {
            font-size: 12px;
            color: #718096;
        }

        .file-details {
            font-size: 11px;
            color: #a0aec0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 5px;
            margin-top: 5px;
        }

        .status-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 20px;
        }

        .status-log {
            background: #1a202c;
            color: #a0aec0;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            height: 200px;
            overflow-y: auto;
            line-height: 1.5;
        }

        .log-entry {
            margin-bottom: 8px;
        }

        .log-info { color: #63b3ed; }
        .log-success { color: #68d391; }
        .log-warning { color: #f6ad55; }
        .log-error { color: #fc8181; }

        .actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .action-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn-primary {
            background: #38a169;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #2f855a;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #cbd5e0;
        }

        .btn-danger {
            background: #e53e3e;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c53030;
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #38a169, #68d391);
            width: 0%;
            transition: width 0.3s ease;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #f0fff4;
            border: 1px solid #68d391;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #38a169;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .empty-state {
            text-align: center;
            color: #a0aec0;
            font-style: italic;
            padding: 40px 20px;
        }

        .error-state {
            text-align: center;
            color: #e53e3e;
            padding: 20px;
            background: #fed7d7;
            border-radius: 8px;
            margin: 10px 0;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #e2e8f0;
            border-radius: 50%;
            border-top-color: #2c5aa0;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .actions {
                flex-direction: column;
                align-items: center;
            }

            .hierarchy-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .metadata-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DICOM File Organizer</h1>
            <p>Advanced DICOM parsing and organization for Flywheel</p>
        </div>

        <div id="connectionStatus" class="connection-status" style="display: none;">
            <div class="status-dot"></div>
            <span>Connected to Flywheel</span>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <h2 style="margin-bottom: 20px; color: #2d3748;">Upload DICOM Files</h2>
                <div id="dropzone" class="drop-zone">
                    <div class="drop-icon">üè•</div>
                    <h3>Drop DICOM files here</h3>
                    <p>Supports .dcm, .dicom files with real DICOM parsing</p>
                    <button type="button" class="browse-btn" onclick="document.getElementById('fileInput').click()">
                        Browse Files
                    </button>
                    <input type="file" id="fileInput" class="file-input" multiple accept=".dcm,.dicom">
                </div>
                
                <div class="progress-bar" id="progressBar" style="display: none;">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <div class="validation-info">
                    <h4>üìã DICOM Validation</h4>
                    <ul>
                        <li>Files are validated for proper DICOM format</li>
                        <li>Metadata extracted from DICOM headers</li>
                        <li>Automatic grouping by Patient ID and Study Date</li>
                        <li>Series organized by acquisition parameters</li>
                    </ul>
                </div>
            </div>

            <div class="hierarchy-section">
                <h2 class="hierarchy-title">
                    üèóÔ∏è Organized Hierarchy
                </h2>
                
                <div id="hierarchyStats" class="hierarchy-stats" style="display: none;">
                    <div class="stat-card">
                        <div class="stat-number" id="subjectCount">0</div>
                        <div class="stat-label">Subjects</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="sessionCount">0</div>
                        <div class="stat-label">Sessions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="acquisitionCount">0</div>
                        <div class="stat-label">Acquisitions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="fileCount">0</div>
                        <div class="stat-label">Files</div>
                    </div>
                </div>

                <div id="hierarchyTree" class="hierarchy-tree">
                    <div class="empty-state">
                        Upload DICOM files to see the organized hierarchy
                    </div>
                </div>
            </div>
        </div>

        <div class="status-section">
            <h3 style="margin-bottom: 15px; color: #2d3748;">Processing Status</h3>
            <div id="statusLog" class="status-log">
                <div class="log-entry log-info">Ready to process DICOM files...</div>
            </div>
        </div>

        <div class="actions">
            <button id="validateBtn" class="action-btn btn-secondary">
                Validate Hierarchy
            </button>
            <button id="uploadBtn" class="action-btn btn-primary" disabled>
                Upload to Flywheel
            </button>
            <button id="clearBtn" class="action-btn btn-danger">
                Clear All
            </button>
        </div>
    </div>

    <!-- DICOM Parser Library -->
    <script src="https://unpkg.com/dicom-parser@1.8.21/dist/dicomParser.min.js"></script>
    <!-- Flywheel Extension SDK -->
    <script src="https://cdn.flywheel.io/sdk/extension/flywheel-extension-0.14.3.min.js"></script>
    
    <script>
        class AdvancedDICOMOrganizer {
            constructor() {
                this.extension = null;
                this.fileGroups = new Map();
                this.processedFiles = [];
                this.isConnected = false;
                this.expandedNodes = new Set();
                this.validationResults = {
                    valid: 0,
                    invalid: 0,
                    errors: []
                };
                this.init();
            }

            async init() {
                try {
                    this.log('Initializing Advanced DICOM Organizer...', 'info');
                    
                    this.extension = await Flywheel.initExtension({
                        scope: 'ReadWrite',
                        validateOrigin: origin => {
                            return origin.includes('localhost') || 
                                   origin.includes('127.0.0.1') || 
                                   origin.endsWith('flywheel.io') ||
                                   origin.includes('127.0.0.1:3000'); // For development
                        }
                    });

                    this.isConnected = true;
                    this.log('Successfully connected to Flywheel!', 'success');
                    this.log(`Project: ${this.extension.container.label || 'Unknown'}`, 'info');
                    this.log(`Container Type: ${this.extension.container.container_type}`, 'info');
                    this.updateConnectionStatus();
                    
                } catch (error) {
                    this.log(`Failed to initialize extension: ${error.message}`, 'error');
                    this.log('Running in demo mode without Flywheel connection', 'warning');
                }
                
                this.setupEventListeners();
            }

            updateConnectionStatus() {
                const statusEl = document.getElementById('connectionStatus');
                if (this.isConnected) {
                    statusEl.style.display = 'flex';
                    statusEl.innerHTML = `
                        <div class="status-dot"></div>
                        <span>Connected to Flywheel - Project: ${this.extension.container.label || 'Unknown'}</span>
                    `;
                }
            }

            setupEventListeners() {
                const dropzone = document.getElementById('dropzone');
                const fileInput = document.getElementById('fileInput');
                const uploadBtn = document.getElementById('uploadBtn');
                const clearBtn = document.getElementById('clearBtn');
                const validateBtn = document.getElementById('validateBtn');

                // Drag and drop events
                dropzone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropzone.classList.add('dragover');
                });

                dropzone.addEventListener('dragleave', () => {
                    dropzone.classList.remove('dragover');
                });

                dropzone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropzone.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });

                dropzone.addEventListener('click', () => {
                    fileInput.click();
                });

                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                uploadBtn.addEventListener('click', () => {
                    this.uploadToFlywheel();
                });

                clearBtn.addEventListener('click', () => {
                    this.clearAll();
                });

                validateBtn.addEventListener('click', () => {
                    this.validateHierarchy();
                });
            }

            async handleFiles(files) {
                this.log(`Processing ${files.length} files with DICOM parser...`, 'info');
                document.getElementById('dropzone').classList.add('processing');
                
                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                progressBar.style.display = 'block';

                this.validationResults = { valid: 0, invalid: 0, errors: [] };

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const progress = ((i + 1) / files.length) * 100;
                    progressFill.style.width = `${progress}%`;

                    try {
                        await this.processDICOMFile(file);
                        this.validationResults.valid++;
                    } catch (error) {
                        this.validationResults.invalid++;
                        this.validationResults.errors.push(`${file.name}: ${error.message}`);
                        this.log(`Error processing ${file.name}: ${error.message}`, 'error');
                    }
                }

                document.getElementById('dropzone').classList.remove('processing');
                progressBar.style.display = 'none';
                
                this.updateHierarchyDisplay();
                this.updateStats();
                this.updateUploadButton();
                
                this.log(`Processing complete: ${this.validationResults.valid} valid, ${this.validationResults.invalid} invalid files`, 
                    this.validationResults.invalid > 0 ? 'warning' : 'success');
            }

            async processDICOMFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            const arrayBuffer = e.target.result;
                            const byteArray = new Uint8Array(arrayBuffer);
                            
                            // Parse DICOM file
                            const dataSet = dicomParser.parseDicom(byteArray);
                            
                            // Extract comprehensive metadata
                            const metadata = this.extractDICOMMetadata(dataSet, file);
                            
                            // Validate required fields
                            this.validateDICOMMetadata(metadata);
                            
                            // Organize into hierarchy
                            this.organizeDICOMFile(file, metadata);
                            
                            this.log(`Parsed: ${file.name} - Patient: ${metadata.patientName}, Study: ${metadata.studyDescription}`, 'success');
                            resolve(metadata);
                            
                        } catch (error) {
                            reject(new Error(`DICOM parsing failed: ${error.message}`));
                        }
                    };
                    
                    reader.onerror = () => {
                        reject(new Error('Failed to read file'));
                    };
                    
                    reader.readAsArrayBuffer(file);
                });
            }

            extractDICOMMetadata(dataSet, file) {
                const getString = (tag) => {
                    try {
                        const element = dataSet.elements[tag];
                        return element ? dataSet.string(tag).trim() : '';
                    } catch (e) {
                        return '';
                    }
                };

                const getNumber = (tag) => {
                    try {
                        const element = dataSet.elements[tag];
                        return element ? dataSet.intString(tag) : '';
                    } catch (e) {
                        return '';
                    }
                };

                const getDate = (tag) => {
                    try {
                        const dateStr = getString(tag);
                        if (dateStr && dateStr.length === 8) {
                            return `${dateStr.substring(0,4)}-${dateStr.substring(4,6)}-${dateStr.substring(6,8)}`;
                        }
                        return dateStr;
                    } catch (e) {
                        return '';
                    }
                };

                const getTime = (tag) => {
                    try {
                        const timeStr = getString(tag);
                        if (timeStr && timeStr.length >= 6) {
                            return `${timeStr.substring(0,2)}:${timeStr.substring(2,4)}:${timeStr.substring(4,6)}`;
                        }
                        return timeStr;
                    } catch (e) {
                        return '';
                    }
                };

                return {
                    // Patient Information
                    patientName: getString('x00100010') || 'Unknown Patient',
                    patientId: getString('x00100020') || `Unknown_${Date.now()}`,
                    patientBirthDate: getDate('x00100030'),
                    patientSex: getString('x00100040'),
                    patientAge: getString('x00101010'),
                    
                    // Study Information
                    studyInstanceUID: getString('x0020000d') || `1.2.3.${Date.now()}.1`,
                    studyDate: getDate('x00080020') || new Date().toISOString().split('T')[0],
                    studyTime: getTime('x00080030') || '120000',
                    studyDescription: getString('x00081030') || 'Unknown Study',
                    studyId: getString('x00200010') || '1',
                    accessionNumber: getString('x00080050'),
                    
                    // Series Information
                    seriesInstanceUID: getString('x0020000e') || `1.2.3.${Date.now()}.2`,
                    seriesNumber: getNumber('x00200011') || '1',
                    seriesDescription: getString('x0008103e') || 'Unknown Series',
                    modality: getString('x00080060') || 'UN',
                    seriesDate: getDate('x00080021'),
                    seriesTime: getTime('x00080031'),
                    
                    // Instance Information
                    sopInstanceUID: getString('x00080018') || `1.2.3.${Date.now()}.3`,
                    instanceNumber: getNumber('x00200013') || '1',
                    
                    // Technical Parameters
                    manufacturer: getString('x00080070'),
                    manufacturerModelName: getString('x00081090'),
                    softwareVersions: getString('x00181020'),
                    protocolName: getString('x00181030'),
                    
                    // Image Parameters (if applicable)
                    rows: getNumber('x00280010'),
                    columns: getNumber('x00280011'),
                    pixelSpacing: getString('x00280030'),
                    sliceThickness: getString('x00180050'),
                    
                    // File Information
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: file.type || 'application/dicom'
                };
            }

            validateDICOMMetadata(metadata) {
                const required = ['patientId', 'studyInstanceUID', 'seriesInstanceUID', 'sopInstanceUID'];
                const missing = required.filter(field => !metadata[field]);
                
                if (missing.length > 0) {
                    throw new Error(`Missing required DICOM fields: ${missing.join(', ')}`);
                }
                
                // Additional validation
                if (!metadata.studyDate || metadata.studyDate.length < 8) {
                    throw new Error('Invalid or missing study date');
                }
            }

            organizeDICOMFile(file, metadata) {
                const groupKey = `${metadata.patientId}_${metadata.studyInstanceUID}`;

                if (!this.fileGroups.has(groupKey)) {
                    this.fileGroups.set(groupKey, {
                        subject: {
                            id: metadata.patientId,
                            name: metadata.patientName,
                            birthDate: metadata.patientBirthDate,
                            sex: metadata.patientSex,
                            age: metadata.patientAge
                        },
                        session: {
                            uid: metadata.studyInstanceUID,
                            date: metadata.studyDate,
                            time: metadata.studyTime,
                            description: metadata.studyDescription,
                            id: metadata.studyId,
                            accessionNumber: metadata.accessionNumber
                        },
                        acquisitions: new Map()
                    });
                }

                const group = this.fileGroups.get(groupKey);
                const acquisitionKey = metadata.seriesInstanceUID;

                if (!group.acquisitions.has(acquisitionKey)) {
                    group.acquisitions.set(acquisitionKey, {
                        uid: metadata.seriesInstanceUID,
                        number: metadata.seriesNumber,
                        description: metadata.seriesDescription,
                        modality: metadata.modality,
                        date: metadata.seriesDate,
                        time: metadata.seriesTime,
                        manufacturer: metadata.manufacturer,
                        model: metadata.manufacturerModelName,
                        protocol: metadata.protocolName,
                        files: []
                    });
                }

                group.acquisitions.get(acquisitionKey).files.push({
                    file: file,
                    metadata: metadata
                });

                this.processedFiles.push({ file, metadata });
            }

            updateStats() {
                const stats = this.calculateStats();
                
                document.getElementById('subjectCount').textContent = stats.subjects;
                document.getElementById('sessionCount').textContent = stats.sessions;
                document.getElementById('acquisitionCount').textContent = stats.acquisitions;
                document.getElementById('fileCount').textContent = stats.files;
                
                const statsEl = document.getElementById('hierarchyStats');
                statsEl.style.display = stats.files > 0 ? 'grid' : 'none';
            }

            calculateStats() {
                const stats = {
                    subjects: this.fileGroups.size,
                    sessions: this.fileGroups.size, // One session per study
                    acquisitions: 0,
                    files: 0
                };

                for (const group of this.fileGroups.values()) {
                    stats.acquisitions += group.acquisitions.size;
                    for (const acquisition of group.acquisitions.values()) {
                        stats.files += acquisition.files.length;
                    }
                }

                return stats;
            }

            updateHierarchyDisplay() {
                const treeEl = document.getElementById('hierarchyTree');
                
                if (this.fileGroups.size === 0) {
                    treeEl.innerHTML = '<div class="empty-state">Upload DICOM files to see the organized hierarchy</div>';
                    return;
                }

                let html = '';
                
                for (const [groupKey, group] of this.fileGroups) {
                    const totalFiles = Array.from(group.acquisitions.values())
                        .reduce((sum, acq) => sum + acq.files.length, 0);

                    const subjectExpanded = this.expandedNodes.has(`subject_${groupKey}`);
                    const sessionExpanded = this.expandedNodes.has(`session_${groupKey}`);

                    html += `
                        <div class="tree-level">
                            <div class="tree-node has-files expandable" onclick="organizer.toggleNode('subject_${groupKey}')">
                                <div class="node-header">
                                    <div class="node-title">
                                        <span class="expand-icon ${subjectExpanded ? 'expanded' : ''}">‚ñ∂</span>
                                        üë§ Subject: ${group.subject.name}
                                    </div>
                                    <div class="file-count">${totalFiles} files</div>
                                </div>
                                <div class="node-details">
                                    Patient ID: ${group.subject.id} | 
                                    Sex: ${group.subject.sex || 'Unknown'} | 
                                    Age: ${group.subject.age || 'Unknown'}
                                </div>
                                
                                ${subjectExpanded ? `
                                    <div class="tree-level">
                                        <div class="tree-node has-files expandable" onclick="organizer.toggleNode('session_${groupKey}', event)">
                                            <div class="node-header">
                                                <div class="node-title">
                                                    <span class="expand-icon ${sessionExpanded ? 'expanded' : ''}">‚ñ∂</span>
                                                    üìÖ Session: ${group.session.description}
                                                </div>
                                            </div>
                                            <div class="node-details">
                                                Study Date: ${group.session.date} | 
                                                Time: ${group.session.time} |
                                                Accession: ${group.session.accessionNumber || 'N/A'}
                                            </div>
                                            
                                            ${sessionExpanded ? this.renderAcquisitions(group.acquisitions, groupKey) : ''}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }

                treeEl.innerHTML = html;
            }

            renderAcquisitions(acquisitions, groupKey) {
                let html = '';
                
                for (const [key, acquisition] of acquisitions) {
                    const acquisitionExpanded = this.expandedNodes.has(`acquisition_${groupKey}_${key}`);
                    
                    html += `
                        <div class="tree-level">
                            <div class="tree-node has-files expandable" onclick="organizer.toggleNode('acquisition_${groupKey}_${key}', event)">
                                <div class="node-header">
                                    <div class="node-title">
                                        <span class="expand-icon ${acquisitionExpanded ? 'expanded' : ''}">‚ñ∂</span>
                                        üî¨ ${acquisition.modality} - Series ${acquisition.number}
                                    </div>
                                    <div class="file-count">${acquisition.files.length} files</div>
                                </div>
                                <div class="node-details">${acquisition.description}</div>
                                
                                <div class="metadata-grid">
                                    <div class="metadata-item">
                                        <div class="metadata-label">Modality</div>
                                        <div class="metadata-value">${acquisition.modality}</div>
                                    </div>
                                    <div class="metadata-item">
                                        <div class="metadata-label">Manufacturer</div>
                                        <div class="metadata-value">${acquisition.manufacturer || 'Unknown'}</div>
                                    </div>
                                    <div class="metadata-item">
                                        <div class="metadata-label">Protocol</div>
                                        <div class="metadata-value">${acquisition.protocol || 'N/A'}</div>
                                    </div>
                                    <div class="metadata-item">
                                        <div class="metadata-label">Series UID</div>
                                        <div class="metadata-value">${acquisition.uid.substring(0, 20)}...</div>
                                    </div>
                                </div>
                                
                                ${acquisitionExpanded ? `
                                    <ul class="file-list">
                                        ${acquisition.files.map(fileData => `
                                            <li class="file-item">
                                                <div class="file-header">
                                                    <span class="file-name">${fileData.file.name}</span>
                                                    <span class="file-meta">${this.formatFileSize(fileData.file.size)}</span>
                                                </div>
                                                <div class="file-details">
                                                    <span>Instance: ${fileData.metadata.instanceNumber}</span>
                                                    <span>Rows: ${fileData.metadata.rows || 'N/A'}</span>
                                                    <span>Columns: ${fileData.metadata.columns || 'N/A'}</span>
                                                    <span>Thickness: ${fileData.metadata.sliceThickness || 'N/A'}mm</span>
                                                </div>
                                            </li>
                                        `).join('')}
                                    </ul>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }
                
                return html;
            }

            toggleNode(nodeId, event) {
                if (event) {
                    event.stopPropagation();
                }
                
                if (this.expandedNodes.has(nodeId)) {
                    this.expandedNodes.delete(nodeId);
                } else {
                    this.expandedNodes.add(nodeId);
                }
                
                this.updateHierarchyDisplay();
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            async validateHierarchy() {
                this.log('üîç Validating DICOM hierarchy and Flywheel readiness...', 'info');
                
                if (this.fileGroups.size === 0) {
                    this.log('‚ö†Ô∏è No files to validate', 'warning');
                    return;
                }

                let issues = [];
                let warnings = [];
                
                // Check Flywheel connection
                if (!this.isConnected) {
                    issues.push('Not connected to Flywheel instance');
                } else {
                    try {
                        await this.validateConnection();
                        this.log('‚úÖ Flywheel connection verified', 'success');
                    } catch (error) {
                        issues.push(`Flywheel connection issue: ${error.message}`);
                    }
                }

                // Validate each subject group
                for (const [groupKey, group] of this.fileGroups) {
                    // Validate subject data
                    if (!group.subject.id || group.subject.id.includes('Unknown')) {
                        issues.push(`Subject ${groupKey}: Missing or invalid Patient ID`);
                    }
                    
                    if (!group.subject.name || group.subject.name.includes('Unknown')) {
                        warnings.push(`Subject ${groupKey}: Missing or generic Patient Name`);
                    }
                    
                    // Validate session data
                    if (!group.session.uid || !group.session.date) {
                        issues.push(`Session ${groupKey}: Missing Study UID or Date`);
                    }
                    
                    // Check for reasonable study date
                    const studyDate = new Date(group.session.date);
                    const now = new Date();
                    const oneYearAgo = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
                    const oneYearFromNow = new Date(now.getFullYear() + 1, now.getMonth(), now.getDate());
                    
                    if (studyDate < oneYearAgo || studyDate > oneYearFromNow) {
                        warnings.push(`Session ${groupKey}: Study date seems unusual (${group.session.date})`);
                    }
                    
                    // Validate acquisitions
                    if (group.acquisitions.size === 0) {
                        issues.push(`Session ${groupKey}: No acquisitions found`);
                    }
                    
                    for (const [acqKey, acquisition] of group.acquisitions) {
                        if (!acquisition.uid || !acquisition.modality) {
                            issues.push(`Acquisition ${acqKey}: Missing Series UID or Modality`);
                        }
                        
                        if (acquisition.files.length === 0) {
                            issues.push(`Acquisition ${acqKey}: No files`);
                        }
                        
                        // Check for reasonable file count per series
                        if (acquisition.files.length > 1000) {
                            warnings.push(`Acquisition ${acqKey}: Large number of files (${acquisition.files.length}), upload may take time`);
                        }
                        
                        // Validate modality
                        const validModalities = ['CT', 'MR', 'US', 'XA', 'RF', 'DX', 'CR', 'MG', 'PT', 'NM', 'SC', 'OT'];
                        if (!validModalities.includes(acquisition.modality)) {
                            warnings.push(`Acquisition ${acqKey}: Unusual modality "${acquisition.modality}"`);
                        }
                    }
                }

                // Check for potential duplicates
                const patientIds = Array.from(this.fileGroups.values()).map(g => g.subject.id);
                const duplicatePatients = patientIds.filter((id, index) => patientIds.indexOf(id) !== index);
                if (duplicatePatients.length > 0) {
                    warnings.push(`Potential duplicate Patient IDs: ${[...new Set(duplicatePatients)].join(', ')}`);
                }

                // Report results
                if (issues.length === 0 && warnings.length === 0) {
                    this.log('‚úÖ Hierarchy validation passed - all data is valid and ready for upload', 'success');
                    this.log(`üìä Summary: ${this.fileGroups.size} subjects, ${this.calculateStats().acquisitions} acquisitions, ${this.getTotalFileCount()} files`, 'info');
                } else {
                    if (issues.length > 0) {
                        this.log(`‚ùå Hierarchy validation found ${issues.length} critical issues:`, 'error');
                        issues.forEach(issue => this.log(`  ‚ñ∏ ${issue}`, 'error'));
                    }
                    
                    if (warnings.length > 0) {
                        this.log(`‚ö†Ô∏è Hierarchy validation found ${warnings.length} warnings:`, 'warning');
                        warnings.forEach(warning => this.log(`  ‚ñ∏ ${warning}`, 'warning'));
                    }
                    
                    if (issues.length > 0) {
                        this.log('üö´ Upload blocked due to critical issues. Please resolve them before uploading.', 'error');
                        document.getElementById('uploadBtn').disabled = true;
                        document.getElementById('uploadBtn').textContent = 'Resolve Issues First';
                    } else {
                        this.log('‚ö†Ô∏è Upload can proceed but warnings should be reviewed.', 'warning');
                    }
                }

                return { issues, warnings };
            }

            async withTimeout(promise, timeoutMs = 30000) {
                const timeout = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
                );
                
                return Promise.race([promise, timeout]);
            }

            async retryOperation(operation, maxRetries = 3, baseDelay = 1000) {
                let lastError;
                
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        return await operation();
                    } catch (error) {
                        lastError = error;
                        
                        if (attempt < maxRetries) {
                            const delay = baseDelay * Math.pow(2, attempt - 1); // Exponential backoff
                            this.log(`‚è≥ Retry attempt ${attempt}/${maxRetries} in ${delay}ms`, 'warning');
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }
                
                throw lastError;
            }

            createSearchableMetadata(metadata) {
                // Create a flattened, searchable version of DICOM metadata
                return {
                    // Patient information
                    patient_id: metadata.patientId,
                    patient_name: metadata.patientName?.toLowerCase(),
                    patient_sex: metadata.patientSex?.toLowerCase(),
                    patient_age: metadata.patientAge,
                    
                    // Study information  
                    study_uid: metadata.studyInstanceUID,
                    study_date: metadata.studyDate,
                    study_description: metadata.studyDescription?.toLowerCase(),
                    accession_number: metadata.accessionNumber,
                    
                    // Series information
                    series_uid: metadata.seriesInstanceUID,
                    series_number: metadata.seriesNumber,
                    modality: metadata.modality?.toLowerCase(),
                    series_description: metadata.seriesDescription?.toLowerCase(),
                    
                    // Technical parameters
                    manufacturer: metadata.manufacturer?.toLowerCase(),
                    model: metadata.manufacturerModelName?.toLowerCase(),
                    protocol: metadata.protocolName?.toLowerCase(),
                    
                    // Import metadata
                    import_timestamp: new Date().toISOString(),
                    import_source: 'dicom-organizer',
                    original_filename: metadata.fileName
                };
            }

            sanitizeContainerLabel(label) {
                // Sanitize labels for Flywheel containers
                return label
                    .replace(/[^\w\s\-\.]/g, '') // Remove special characters except word chars, spaces, hyphens, dots
                    .replace(/\s+/g, ' ') // Collapse multiple spaces
                    .trim()
                    .substring(0, 100); // Limit length
            }

            estimateUploadTime(totalFiles, totalSizeBytes) {
                // Rough estimation based on typical upload speeds
                const avgFileProcessingTime = 2; // seconds per file
                const avgUploadSpeedMBps = 5; // MB per second
                
                const processingTime = totalFiles * avgFileProcessingTime;
                const uploadTime = (totalSizeBytes / (1024 * 1024)) / avgUploadSpeedMBps;
                
                return Math.max(processingTime, uploadTime);
            }

            formatDuration(seconds) {
                if (seconds < 60) return `${Math.round(seconds)}s`;
                if (seconds < 3600) return `${Math.round(seconds / 60)}m ${Math.round(seconds % 60)}s`;
                return `${Math.round(seconds / 3600)}h ${Math.round((seconds % 3600) / 60)}m`;
            }

            updateUploadButton() {
                const uploadBtn = document.getElementById('uploadBtn');
                const validateBtn = document.getElementById('validateBtn');
                const fileCount = this.getTotalFileCount();
                
                // Calculate total file size for time estimation
                const totalSize = this.processedFiles.reduce((sum, fileData) => sum + fileData.file.size, 0);
                
                if (fileCount === 0) {
                    uploadBtn.disabled = true;
                    uploadBtn.textContent = 'Upload to Flywheel';
                    validateBtn.disabled = true;
                    return;
                }

                validateBtn.disabled = false;
                
                if (this.isConnected) {
                    const estimatedTime = this.estimateUploadTime(fileCount, totalSize);
                    uploadBtn.innerHTML = `
                        Upload ${fileCount} files to Flywheel
                        <br><small style="font-size: 12px; opacity: 0.8;">
                            Est. time: ${this.formatDuration(estimatedTime)} | 
                            Size: ${this.formatFileSize(totalSize)}
                        </small>
                    `;
                    uploadBtn.disabled = false;
                } else {
                    uploadBtn.innerHTML = `
                        ${fileCount} files ready (Demo mode)
                        <br><small style="font-size: 12px; opacity: 0.8;">
                            Connect to Flywheel to upload
                        </small>
                    `;
                    uploadBtn.disabled = false; // Allow demo mode
                }
            }

            getTotalFileCount() {
                let total = 0;
                for (const group of this.fileGroups.values()) {
                    for (const acquisition of group.acquisitions.values()) {
                        total += acquisition.files.length;
                    }
                }
                return total;
            }

            async uploadToFlywheel() {
                if (!this.isConnected) {
                    this.log('Demo mode: Simulating upload to Flywheel...', 'warning');
                    await this.simulateUpload();
                    return;
                }

                this.log('üöÄ Starting upload to Flywheel...', 'info');
                const uploadBtn = document.getElementById('uploadBtn');
                const originalText = uploadBtn.textContent;
                uploadBtn.disabled = true;
                uploadBtn.innerHTML = '<span class="loading-spinner"></span> Uploading...';

                const startTime = Date.now();
                let uploadedFiles = 0;
                let failedFiles = 0;
                const totalFiles = this.getTotalFileCount();

                try {
                    // Validate connection before starting
                    await this.validateConnection();
                    
                    this.log(`üìä Starting upload of ${totalFiles} files across ${this.fileGroups.size} subjects`, 'info');

                    for (const [groupKey, group] of this.fileGroups) {
                        try {
                            const groupResult = await this.uploadGroupWithRetry(group, 3);
                            uploadedFiles += groupResult.uploadedCount;
                            failedFiles += groupResult.failedCount;
                            
                        } catch (error) {
                            this.log(`‚ùå Failed to upload group ${group.subject.name}: ${error.message}`, 'error');
                            failedFiles += Array.from(group.acquisitions.values())
                                .reduce((sum, acq) => sum + acq.files.length, 0);
                        }
                    }
                    
                    const duration = Math.round((Date.now() - startTime) / 1000);
                    
                    if (failedFiles === 0) {
                        this.log(`‚úÖ Upload complete! ${uploadedFiles} files uploaded in ${duration}s`, 'success');
                        uploadBtn.textContent = '‚úÖ Upload Complete!';
                        uploadBtn.style.background = '#38a169';
                    } else {
                        this.log(`‚ö†Ô∏è Upload finished with errors: ${uploadedFiles} successful, ${failedFiles} failed in ${duration}s`, 'warning');
                        uploadBtn.textContent = `‚ö†Ô∏è ${uploadedFiles}/${totalFiles} Uploaded`;
                        uploadBtn.style.background = '#ed8936';
                        uploadBtn.disabled = false;
                    }
                    
                } catch (error) {
                    const duration = Math.round((Date.now() - startTime) / 1000);
                    this.handleUploadError(error, uploadBtn, originalText, duration);
                }
            }

            async validateConnection() {
                try {
                    // Test connection by getting current container info
                    await this.extension.getContainer(this.extension.container.container_type, this.extension.container._id);
                    this.log('‚úÖ Connection validated', 'success');
                } catch (error) {
                    throw new Error(`Connection validation failed: ${error.message}`);
                }
            }

            async uploadGroupWithRetry(group, maxRetries = 3) {
                let uploadedCount = 0;
                let failedCount = 0;
                let retryCount = 0;

                while (retryCount < maxRetries) {
                    try {
                        await this.uploadGroup(group);
                        
                        // Count successful files
                        uploadedCount = Array.from(group.acquisitions.values())
                            .reduce((sum, acq) => sum + acq.files.length, 0);
                        break;
                        
                    } catch (error) {
                        retryCount++;
                        
                        if (retryCount < maxRetries) {
                            const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff
                            this.log(`‚è≥ Retrying group ${group.subject.name} in ${delay/1000}s (attempt ${retryCount}/${maxRetries})`, 'warning');
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            this.log(`‚ùå Max retries exceeded for group ${group.subject.name}`, 'error');
                            failedCount = Array.from(group.acquisitions.values())
                                .reduce((sum, acq) => sum + acq.files.length, 0);
                            throw error;
                        }
                    }
                }

                return { uploadedCount, failedCount };
            }

            handleUploadError(error, uploadBtn, originalText, duration) {
                let errorMessage = 'Unknown error occurred';
                let actionAdvice = 'Please try again';

                // Categorize errors and provide specific advice
                if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage = 'Network connection error';
                    actionAdvice = 'Check your internet connection and try again';
                } else if (error.message.includes('permission') || error.message.includes('auth')) {
                    errorMessage = 'Permission or authentication error';
                    actionAdvice = 'Check your Flywheel permissions';
                } else if (error.message.includes('quota') || error.message.includes('space')) {
                    errorMessage = 'Storage quota exceeded';
                    actionAdvice = 'Contact your Flywheel administrator';
                } else if (error.message.includes('validation')) {
                    errorMessage = 'Data validation error';
                    actionAdvice = 'Check your DICOM files and try again';
                } else {
                    errorMessage = error.message;
                }

                this.log(`‚ùå Upload failed after ${duration}s: ${errorMessage}`, 'error');
                this.log(`üí° Suggestion: ${actionAdvice}`, 'info');
                
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'üîÑ Retry Upload';
                uploadBtn.style.background = '#e53e3e';
                
                // Show error details in UI
                this.showErrorDialog(errorMessage, actionAdvice, error.stack);
            }

            showErrorDialog(message, advice, details) {
                // Create a simple error dialog (could be enhanced with a modal)
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-state';
                errorDiv.innerHTML = `
                    <h4>‚ùå Upload Error</h4>
                    <p><strong>Error:</strong> ${message}</p>
                    <p><strong>Suggestion:</strong> ${advice}</p>
                    <details style="margin-top: 10px;">
                        <summary>Technical Details</summary>
                        <pre style="font-size: 11px; margin-top: 5px;">${details || 'No additional details available'}</pre>
                    </details>
                    <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 5px 10px; border: none; background: #e53e3e; color: white; border-radius: 4px; cursor: pointer;">
                        Dismiss
                    </button>
                `;
                
                const statusSection = document.querySelector('.status-section');
                statusSection.insertBefore(errorDiv, statusSection.firstChild);
                
                // Auto-remove after 30 seconds
                setTimeout(() => {
                    if (errorDiv.parentElement) {
                        errorDiv.remove();
                    }
                }, 30000);
            }

            async simulateUpload() {
                const uploadBtn = document.getElementById('uploadBtn');
                uploadBtn.innerHTML = '<span class="loading-spinner"></span> Simulating upload...';
                uploadBtn.disabled = true;

                let fileCount = 0;
                const totalFiles = this.getTotalFileCount();

                for (const [groupKey, group] of this.fileGroups) {
                    this.log(`üìÅ Creating Subject: ${group.subject.name}`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    this.log(`üìÖ Creating Session: ${group.session.description}`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    for (const [seriesKey, acquisition] of group.acquisitions) {
                        this.log(`üî¨ Creating Acquisition: ${acquisition.modality} Series ${acquisition.number}`, 'info');
                        await new Promise(resolve => setTimeout(resolve, 150));
                        
                        for (const fileData of acquisition.files) {
                            fileCount++;
                            this.log(`üìÑ Uploading ${fileData.file.name} (${fileCount}/${totalFiles})`, 'success');
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                }

                uploadBtn.textContent = 'Demo Upload Complete!';
                this.log('‚úÖ Demo upload simulation completed', 'success');
            }

            async uploadGroup(group) {
                this.log(`Creating hierarchy for Subject: ${group.subject.name}`, 'info');

                try {
                    // Get current project as parent
                    const project = this.extension.container;
                    
                    // Create or find subject
                    const subject = await this.createOrFindSubject(project, group.subject);
                    this.log(`‚úÖ Subject ready: ${subject.label}`, 'success');

                    // Create or find session  
                    const session = await this.createOrFindSession(subject, group.session);
                    this.log(`‚úÖ Session ready: ${session.label}`, 'success');

                    // Create acquisitions and upload files
                    for (const [seriesKey, acquisition] of group.acquisitions) {
                        const acq = await this.createOrFindAcquisition(session, acquisition);
                        this.log(`‚úÖ Acquisition ready: ${acq.label}`, 'success');
                        
                        for (const fileData of acquisition.files) {
                            await this.uploadFileToContainer(acq, fileData.file, fileData.metadata);
                            this.log(`‚úÖ Uploaded: ${fileData.file.name}`, 'success');
                        }
                    }
                    
                } catch (error) {
                    throw new Error(`Failed to upload group ${group.subject.name}: ${error.message}`);
                }
            }

            async createOrFindSubject(project, subjectData) {
                try {
                    // Search for existing subject by Patient ID
                    this.log(`üîç Searching for existing subject: ${subjectData.id}`, 'info');
                    
                    const existingSubjects = await this.withTimeout(
                        this.searchContainers(project._id, 'subject', {
                            'code': subjectData.id
                        }),
                        10000 // 10 second timeout for search
                    );

                    if (existingSubjects.length > 0) {
                        this.log(`üìã Found existing subject: ${existingSubjects[0].label}`, 'info');
                        
                        // Update existing subject with any new metadata
                        await this.updateSubjectMetadata(existingSubjects[0], subjectData);
                        return existingSubjects[0];
                    }

                    // Create new subject
                    this.log(`‚ûï Creating new subject: ${subjectData.name}`, 'info');
                    
                    const sanitizedLabel = this.sanitizeContainerLabel(subjectData.name || subjectData.id);
                    const subjectPayload = {
                        label: sanitizedLabel,
                        code: subjectData.id,
                        sex: subjectData.sex || null,
                        cohort: 'DICOM Import',
                        info: {
                            DICOM: {
                                PatientName: subjectData.name,
                                PatientID: subjectData.id,
                                PatientBirthDate: subjectData.birthDate || null,
                                PatientSex: subjectData.sex || null,
                                PatientAge: subjectData.age || null,
                                ImportTimestamp: new Date().toISOString(),
                                ImportSource: 'dicom-organizer'
                            },
                            searchable: {
                                patient_id: subjectData.id.toLowerCase(),
                                patient_name: subjectData.name?.toLowerCase() || '',
                                patient_sex: subjectData.sex?.toLowerCase() || 'unknown',
                                import_date: new Date().toISOString().split('T')[0]
                            }
                        },
                        tags: [
                            'dicom-import', 
                            `patient-${subjectData.id.toLowerCase()}`,
                            'dicom-organizer-subject'
                        ]
                    };

                    const newSubject = await this.withTimeout(
                        this.retryOperation(async () => {
                            return await this.extension.createContainer('subject', project._id, subjectPayload);
                        }, 3, 1000),
                        30000 // 30 second timeout for creation
                    );
                    
                    // Add additional searchable tags
                    await this.tagContainer(newSubject, {
                        'dicom:patient_id': subjectData.id,
                        'dicom:patient_name': subjectData.name || subjectData.id,
                        'dicom:patient_sex': subjectData.sex || 'unknown',
                        'import:source': 'dicom-organizer',
                        'import:timestamp': new Date().toISOString(),
                        'import:version': '2.0'
                    });

                    this.log(`‚úÖ Created subject: ${newSubject.label} (${newSubject._id})`, 'success');
                    return newSubject;
                    
                } catch (error) {
                    const errorMsg = `Subject creation failed for ${subjectData.id}: ${error.message}`;
                    this.log(`‚ùå ${errorMsg}`, 'error');
                    throw new Error(errorMsg);
                }
            }

            async updateSubjectMetadata(subject, subjectData) {
                try {
                    // Update existing subject with new DICOM data if needed
                    const updatePayload = {
                        set: {
                            info: {
                                ...subject.info,
                                DICOM: {
                                    ...subject.info?.DICOM,
                                    PatientName: subjectData.name,
                                    PatientID: subjectData.id,
                                    PatientBirthDate: subjectData.birthDate || subject.info?.DICOM?.PatientBirthDate,
                                    PatientSex: subjectData.sex || subject.info?.DICOM?.PatientSex,
                                    PatientAge: subjectData.age || subject.info?.DICOM?.PatientAge,
                                    LastUpdated: new Date().toISOString()
                                }
                            }
                        }
                    };

                    await this.extension.updateContainerInfo(subject, updatePayload);
                    this.log(`üîÑ Updated existing subject metadata: ${subject.label}`, 'info');
                    
                } catch (error) {
                    this.log(`‚ö†Ô∏è Failed to update subject metadata: ${error.message}`, 'warning');
                    // Don't fail the process if metadata update fails
                }
            }

            async createOrFindSession(subject, sessionData) {
                try {
                    // Search for existing session by Study Instance UID
                    this.log(`üîç Searching for existing session: ${sessionData.description}`, 'info');
                    
                    const existingSession = await this.searchContainers(subject._id, 'session', {
                        'info.DICOM.StudyInstanceUID': sessionData.uid
                    });

                    if (existingSession.length > 0) {
                        this.log(`üìã Found existing session: ${existingSession[0].label}`, 'info');
                        return existingSession[0];
                    }

                    // Create new session
                    this.log(`‚ûï Creating new session: ${sessionData.description}`, 'info');
                    
                    const sessionPayload = {
                        label: sessionData.description || `Study ${sessionData.date}`,
                        timestamp: this.parseDICOMDateTime(sessionData.date, sessionData.time),
                        info: {
                            DICOM: {
                                StudyInstanceUID: sessionData.uid,
                                StudyDate: sessionData.date,
                                StudyTime: sessionData.time,
                                StudyDescription: sessionData.description,
                                StudyID: sessionData.id,
                                AccessionNumber: sessionData.accessionNumber || null
                            }
                        },
                        tags: ['dicom-import', 'study-' + sessionData.date]
                    };

                    const newSession = await this.extension.createContainer('session', subject._id, sessionPayload);
                    
                    // Add metadata tags
                    await this.tagContainer(newSession, {
                        'dicom:study_uid': sessionData.uid,
                        'dicom:study_date': sessionData.date,
                        'dicom:study_description': sessionData.description || 'unknown',
                        'dicom:accession_number': sessionData.accessionNumber || 'none',
                        'import:source': 'dicom-organizer'
                    });

                    return newSession;
                    
                } catch (error) {
                    throw new Error(`Session creation failed: ${error.message}`);
                }
            }

            async createOrFindAcquisition(session, acquisitionData) {
                try {
                    // Search for existing acquisition by Series Instance UID
                    this.log(`üîç Searching for existing acquisition: Series ${acquisitionData.number}`, 'info');
                    
                    const existingAcquisition = await this.searchContainers(session._id, 'acquisition', {
                        'info.DICOM.SeriesInstanceUID': acquisitionData.uid
                    });

                    if (existingAcquisition.length > 0) {
                        this.log(`üìã Found existing acquisition: ${existingAcquisition[0].label}`, 'info');
                        return existingAcquisition[0];
                    }

                    // Create new acquisition
                    this.log(`‚ûï Creating new acquisition: ${acquisitionData.description}`, 'info');
                    
                    const acquisitionPayload = {
                        label: `${acquisitionData.modality} - ${acquisitionData.description}`,
                        timestamp: this.parseDICOMDateTime(acquisitionData.date, acquisitionData.time),
                        info: {
                            DICOM: {
                                SeriesInstanceUID: acquisitionData.uid,
                                SeriesNumber: acquisitionData.number,
                                SeriesDescription: acquisitionData.description,
                                Modality: acquisitionData.modality,
                                SeriesDate: acquisitionData.date,
                                SeriesTime: acquisitionData.time,
                                Manufacturer: acquisitionData.manufacturer || null,
                                ManufacturerModelName: acquisitionData.model || null,
                                ProtocolName: acquisitionData.protocol || null
                            }
                        },
                        tags: [
                            'dicom-import', 
                            `modality-${acquisitionData.modality.toLowerCase()}`,
                            `series-${acquisitionData.number}`
                        ]
                    };

                    const newAcquisition = await this.extension.createContainer('acquisition', session._id, acquisitionPayload);
                    
                    // Add metadata tags
                    await this.tagContainer(newAcquisition, {
                        'dicom:series_uid': acquisitionData.uid,
                        'dicom:series_number': acquisitionData.number,
                        'dicom:modality': acquisitionData.modality,
                        'dicom:series_description': acquisitionData.description,
                        'dicom:manufacturer': acquisitionData.manufacturer || 'unknown',
                        'dicom:protocol': acquisitionData.protocol || 'unknown',
                        'import:source': 'dicom-organizer'
                    });

                    return newAcquisition;
                    
                } catch (error) {
                    throw new Error(`Acquisition creation failed: ${error.message}`);
                }
            }

            async uploadFileToContainer(container, file, metadata) {
                try {
                    this.log(`üì§ Uploading ${file.name} (${this.formatFileSize(file.size)}) to ${container.label}`, 'info');
                    
                    // Wrap upload with timeout and retry logic
                    return await this.withTimeout(
                        this.retryOperation(async () => {
                            return new Promise((resolve, reject) => {
                                const uploadObservable = this.extension.uploadFile(container, file);
                                let lastProgressUpdate = 0;
                                
                                uploadObservable.subscribe({
                                    next: event => {
                                        if (event.type === 'progress') {
                                            const percent = Math.round((event.loaded / event.total) * 100);
                                            
                                            // Only log progress every 25% to avoid spam
                                            if (percent >= lastProgressUpdate + 25 || percent === 100) {
                                                this.log(`üìä ${file.name}: ${percent}% (${this.formatFileSize(event.loaded)}/${this.formatFileSize(event.total)})`, 'info');
                                                lastProgressUpdate = percent;
                                            }
                                            
                                        } else if (event.type === 'response') {
                                            // File upload complete, now add DICOM metadata
                                            this.addFileMetadata(event.file, metadata)
                                                .then(() => {
                                                    this.log(`‚úÖ ${file.name} uploaded with metadata`, 'success');
                                                    resolve(event.file);
                                                })
                                                .catch(error => {
                                                    // Don't fail upload if metadata fails
                                                    this.log(`‚ö†Ô∏è ${file.name} uploaded but metadata failed: ${error.message}`, 'warning');
                                                    resolve(event.file);
                                                });
                                        }
                                    },
                                    error: error => {
                                        this.log(`‚ùå Upload failed for ${file.name}: ${error.message}`, 'error');
                                        reject(new Error(`File upload failed: ${error.message}`));
                                    }
                                });
                            });
                        }, 2, 2000), // 2 retries with 2 second base delay
                        60000 // 60 second timeout for large files
                    );
                    
                } catch (error) {
                    // Enhanced error context
                    const errorContext = {
                        fileName: file.name,
                        fileSize: file.size,
                        containerType: container.container_type,
                        containerId: container._id,
                        timestamp: new Date().toISOString()
                    };
                    
                    this.log(`‚ùå Failed to upload ${file.name}: ${error.message}`, 'error');
                    this.log(`üîç Error context: ${JSON.stringify(errorContext)}`, 'info');
                    
                    throw new Error(`File upload failed: ${error.message}`);
                }
            }

            async addFileMetadata(file, metadata) {
                try {
                    // Create comprehensive, searchable DICOM metadata
                    const searchableMetadata = this.createSearchableMetadata(metadata);
                    
                    const fileMetadata = {
                        info: {
                            DICOM: {
                                // Core DICOM metadata
                                SOPInstanceUID: metadata.sopInstanceUID,
                                InstanceNumber: metadata.instanceNumber,
                                PatientID: metadata.patientId,
                                StudyInstanceUID: metadata.studyInstanceUID,
                                SeriesInstanceUID: metadata.seriesInstanceUID,
                                
                                // Image parameters
                                Rows: metadata.rows || null,
                                Columns: metadata.columns || null,
                                PixelSpacing: metadata.pixelSpacing || null,
                                SliceThickness: metadata.sliceThickness || null,
                                
                                // Technical parameters
                                Manufacturer: metadata.manufacturer || null,
                                ManufacturerModelName: metadata.manufacturerModelName || null,
                                SoftwareVersions: metadata.softwareVersions || null,
                                ProtocolName: metadata.protocolName || null,
                                
                                // Modality and acquisition info
                                Modality: metadata.modality,
                                SeriesDescription: metadata.seriesDescription,
                                StudyDescription: metadata.studyDescription,
                                
                                // Import metadata
                                ImportTimestamp: new Date().toISOString(),
                                OriginalFilename: metadata.fileName,
                                ImportSource: 'dicom-organizer-v2'
                            },
                            
                            // Searchable tags for easy querying
                            searchable: searchableMetadata
                        },
                        
                        tags: [
                            'dicom-file',
                            `instance-${metadata.instanceNumber}`,
                            `modality-${metadata.modality.toLowerCase()}`,
                            `patient-${metadata.patientId.toLowerCase()}`,
                            `series-${metadata.seriesNumber}`,
                            'dicom-organizer-import'
                        ]
                    };

                    await this.extension.updateFileInfo(file, fileMetadata);
                    this.log(`üè∑Ô∏è Enhanced metadata added to ${file.name}`, 'success');
                    
                } catch (error) {
                    // Don't fail the upload if metadata addition fails
                    this.log(`‚ö†Ô∏è Failed to add metadata to ${file.name}: ${error.message}`, 'warning');
                    
                    // Try basic metadata as fallback
                    try {
                        const basicMetadata = {
                            info: {
                                DICOM: {
                                    SOPInstanceUID: metadata.sopInstanceUID,
                                    PatientID: metadata.patientId,
                                    Modality: metadata.modality,
                                    ImportTimestamp: new Date().toISOString()
                                }
                            },
                            tags: ['dicom-file', 'dicom-organizer-import']
                        };
                        
                        await this.extension.updateFileInfo(file, basicMetadata);
                        this.log(`üè∑Ô∏è Basic metadata added to ${file.name}`, 'info');
                        
                    } catch (fallbackError) {
                        this.log(`‚ùå Failed to add even basic metadata to ${file.name}`, 'error');
                    }
                }
            }

            async searchContainers(parentId, containerType, searchCriteria) {
                try {
                    // Get all containers of the specified type under the parent
                    const containers = await this.extension.getContainers(containerType, {
                        parent: parentId
                    });

                    // Filter containers based on search criteria
                    return containers.filter(container => {
                        return this.matchesSearchCriteria(container, searchCriteria);
                    });
                    
                } catch (error) {
                    this.log(`‚ö†Ô∏è Container search failed: ${error.message}`, 'warning');
                    return []; // Return empty array if search fails
                }
            }

            matchesSearchCriteria(container, criteria) {
                for (const [path, value] of Object.entries(criteria)) {
                    const containerValue = this.getNestedProperty(container, path);
                    if (containerValue !== value) {
                        return false;
                    }
                }
                return true;
            }

            getNestedProperty(obj, path) {
                return path.split('.').reduce((current, key) => {
                    return current && current[key] !== undefined ? current[key] : undefined;
                }, obj);
            }

            async tagContainer(container, tags) {
                try {
                    // Add searchable tags to container
                    const updatePayload = {
                        set: {
                            info: {
                                ...container.info,
                                tags: {
                                    ...container.info?.tags,
                                    ...tags
                                }
                            }
                        }
                    };

                    await this.extension.updateContainerInfo(container, updatePayload);
                    this.log(`üè∑Ô∏è Added tags to ${container.label}`, 'info');
                    
                } catch (error) {
                    this.log(`‚ö†Ô∏è Failed to tag ${container.label}: ${error.message}`, 'warning');
                    // Don't fail the upload if tagging fails
                }
            }

            parseDICOMDateTime(date, time) {
                try {
                    if (!date) return new Date();
                    
                    // Parse DICOM date format (YYYYMMDD)
                    const year = date.substring(0, 4);
                    const month = date.substring(4, 6);
                    const day = date.substring(6, 8);
                    
                    // Parse DICOM time format (HHMMSS or HHMMSS.ffffff)
                    let timeStr = '00:00:00';
                    if (time && time.length >= 6) {
                        const hour = time.substring(0, 2);
                        const minute = time.substring(2, 4);
                        const second = time.substring(4, 6);
                        timeStr = `${hour}:${minute}:${second}`;
                    }
                    
                    return new Date(`${year}-${month}-${day}T${timeStr}`);
                    
                } catch (error) {
                    this.log(`‚ö†Ô∏è Failed to parse DICOM datetime: ${error.message}`, 'warning');
                    return new Date();
                }
            }

            clearAll() {
                this.fileGroups.clear();
                this.processedFiles = [];
                this.expandedNodes.clear();
                this.validationResults = { valid: 0, invalid: 0, errors: [] };
                
                document.getElementById('fileInput').value = '';
                this.updateHierarchyDisplay();
                this.updateStats();
                this.updateUploadButton();
                this.log('üóëÔ∏è Cleared all files and organization', 'warning');
            }

            log(message, type = 'info') {
                const logEl = document.getElementById('statusLog');
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = `[${timestamp}] ${message}`;
                
                logEl.appendChild(entry);
                logEl.scrollTop = logEl.scrollHeight;

                // Keep only last 100 log entries
                while (logEl.children.length > 100) {
                    logEl.removeChild(logEl.firstChild);
                }
            }
        }

        // Initialize the application
        const organizer = new AdvancedDICOMOrganizer();
    </script>
</body>
</html>
