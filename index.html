<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DICOM File Organizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c5aa0;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 16px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .upload-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .drop-zone {
            border: 3px dashed #cbd5e0;
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            background: #f8fafc;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .drop-zone.dragover {
            border-color: #2c5aa0;
            background: #ebf4ff;
        }

        .drop-zone.processing {
            border-color: #f6ad55;
            background: #fffaf0;
        }

        .drop-zone.error {
            border-color: #fc8181;
            background: #fed7d7;
        }

        .drop-icon {
            font-size: 48px;
            margin-bottom: 20px;
            color: #a0aec0;
        }

        .drop-zone h3 {
            margin-bottom: 10px;
            color: #2d3748;
        }

        .drop-zone p {
            color: #718096;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .browse-btn {
            background: #2c5aa0;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .browse-btn:hover {
            background: #2a5298;
        }

        .validation-info {
            background: #e6fffa;
            border: 1px solid #38b2ac;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 14px;
        }

        .validation-info h4 {
            color: #234e52;
            margin-bottom: 8px;
        }

        .validation-info ul {
            color: #285e61;
            margin-left: 20px;
        }

        .hierarchy-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .hierarchy-title {
            margin-bottom: 20px;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hierarchy-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #2c5aa0;
        }

        .stat-label {
            font-size: 12px;
            color: #718096;
            margin-top: 5px;
        }

        .hierarchy-tree {
            border-left: 2px solid #e2e8f0;
            padding-left: 20px;
        }

        .tree-level {
            margin-bottom: 15px;
            position: relative;
        }

        .tree-level::before {
            content: '';
            position: absolute;
            left: -22px;
            top: 15px;
            width: 20px;
            height: 1px;
            background: #e2e8f0;
        }

        .tree-node {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .tree-node.has-files {
            border-color: #68d391;
            background: #f0fff4;
        }

        .tree-node.expandable {
            cursor: pointer;
        }

        .tree-node.expandable:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .node-title {
            font-weight: 600;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .expand-icon {
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .expand-icon.expanded {
            transform: rotate(90deg);
        }

        .file-count {
            background: #2c5aa0;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .node-details {
            font-size: 14px;
            color: #718096;
            margin-bottom: 10px;
        }

        .metadata-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        .metadata-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 8px;
        }

        .metadata-label {
            font-weight: 600;
            color: #4a5568;
        }

        .metadata-value {
            color: #718096;
            word-break: break-all;
        }

        .file-list {
            list-style: none;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 5px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .file-item:hover {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .file-name {
            font-weight: 500;
            color: #2d3748;
        }

        .file-meta {
            font-size: 12px;
            color: #718096;
        }

        .file-details {
            font-size: 11px;
            color: #a0aec0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 5px;
            margin-top: 5px;
        }

        .status-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 20px;
        }

        .status-log {
            background: #1a202c;
            color: #a0aec0;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            height: 200px;
            overflow-y: auto;
            line-height: 1.5;
        }

        .log-entry {
            margin-bottom: 8px;
        }

        .log-info { color: #63b3ed; }
        .log-success { color: #68d391; }
        .log-warning { color: #f6ad55; }
        .log-error { color: #fc8181; }

        .actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .action-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn-primary {
            background: #38a169;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #2f855a;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #cbd5e0;
        }

        .btn-danger {
            background: #e53e3e;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c53030;
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #38a169, #68d391);
            width: 0%;
            transition: width 0.3s ease;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #f0fff4;
            border: 1px solid #68d391;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #38a169;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .empty-state {
            text-align: center;
            color: #a0aec0;
            font-style: italic;
            padding: 40px 20px;
        }

        .error-state {
            text-align: center;
            color: #e53e3e;
            padding: 20px;
            background: #fed7d7;
            border-radius: 8px;
            margin: 10px 0;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #e2e8f0;
            border-radius: 50%;
            border-top-color: #2c5aa0;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .sdk-info {
            background: #fffbeb;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .sdk-info h4 {
            color: #92400e;
            margin-bottom: 8px;
        }

        .sdk-info ul {
            color: #a16207;
            margin-left: 20px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .actions {
                flex-direction: column;
                align-items: center;
            }

            .hierarchy-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .metadata-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DICOM File Organizer</h1>
            <p>Upload DICOM files with hierarchy metadata to Flywheel</p>
        </div>

        <div id="connectionStatus" class="connection-status" style="display: none;">
            <div class="status-dot"></div>
            <span>Connected to Flywheel</span>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <h2 style="margin-bottom: 20px; color: #2d3748;">Upload DICOM Files</h2>
                <div id="dropzone" class="drop-zone">
                    <div class="drop-icon">🏥</div>
                    <h3>Drop DICOM files here</h3>
                    <p>Supports .dcm, .dicom files with real DICOM parsing</p>
                    <button type="button" class="browse-btn" onclick="document.getElementById('fileInput').click()">
                        Browse Files
                    </button>
                    <input type="file" id="fileInput" class="file-input" multiple accept=".dcm,.dicom">
                </div>
                
                <div class="progress-bar" id="progressBar" style="display: none;">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <div class="validation-info">
                    <h4>📋 DICOM Processing</h4>
                    <ul>
                        <li>Files are validated for proper DICOM format</li>
                        <li>Metadata extracted from DICOM headers</li>
                        <li>Automatic grouping by Patient ID and Study Date</li>
                        <li>Complete hierarchy metadata stored in container</li>
                    </ul>
                </div>
            </div>

            <div class="hierarchy-section">
                <h2 class="hierarchy-title">
                    🏗️ Organized Hierarchy
                </h2>
                
                <div id="hierarchyStats" class="hierarchy-stats" style="display: none;">
                    <div class="stat-card">
                        <div class="stat-number" id="subjectCount">0</div>
                        <div class="stat-label">Subjects</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="sessionCount">0</div>
                        <div class="stat-label">Sessions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="acquisitionCount">0</div>
                        <div class="stat-label">Acquisitions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="fileCount">0</div>
                        <div class="stat-label">Files</div>
                    </div>
                </div>

                <div id="hierarchyTree" class="hierarchy-tree">
                    <div class="empty-state">
                        Upload DICOM files to see the organized hierarchy
                    </div>
                </div>
            </div>
        </div>

        <div class="status-section">
            <h3 style="margin-bottom: 15px; color: #2d3748;">Processing Status</h3>
            <div id="statusLog" class="status-log">
                <div class="log-entry log-info">Ready to process DICOM files...</div>
            </div>
        </div>

        <div class="actions">
            <button id="validateBtn" class="action-btn btn-secondary">
                Validate Files
            </button>
            <button id="uploadBtn" class="action-btn btn-primary" disabled>
                Upload to Flywheel
            </button>
            <button id="clearBtn" class="action-btn btn-danger">
                Clear All
            </button>
        </div>
    </div>

    <!-- DICOM Parser Library -->
    <script src="https://unpkg.com/dicom-parser@1.8.21/dist/dicomParser.min.js"></script>
    <!-- Flywheel Extension SDK -->
    <script src="https://cdn.flywheel.io/sdk/extension/flywheel-extension-0.14.3.min.js"></script>
    
    <script>
        class FixedDICOMOrganizer {
            constructor() {
                this.extension = null;
                this.fileGroups = new Map();
                this.processedFiles = [];
                this.isConnected = false;
                this.expandedNodes = new Set();
                this.validationResults = {
                    valid: 0,
                    invalid: 0,
                    errors: []
                };
                this.init();
            }

            async init() {
                try {
                    this.log('Initializing DICOM Organizer with correct SDK methods...', 'info');
                    
                    this.extension = await Flywheel.initExtension({
                        scope: 'ReadWrite',
                        validateOrigin: origin => {
                            return origin.includes('localhost') || 
                                   origin.includes('127.0.0.1') || 
                                   origin.endsWith('flywheel.io') ||
                                   origin.includes('127.0.0.1:3000');
                        }
                    });

                    this.isConnected = true;
                    this.log('✅ Successfully connected to Flywheel!', 'success');
                    this.log(`📁 Container: ${this.extension.container.label || 'Unknown'}`, 'info');
                    this.log(`📂 Type: ${this.extension.container.container_type}`, 'info');
                    this.updateConnectionStatus();
                    
                } catch (error) {
                    this.log(`❌ Failed to initialize extension: ${error.message}`, 'error');
                    this.log('Running in demo mode without Flywheel connection', 'warning');
                }
                
                this.setupEventListeners();
            }

            updateConnectionStatus() {
                const statusEl = document.getElementById('connectionStatus');
                const sdkInfoEl = document.getElementById('sdkInfo');
                const sdkInfoContent = document.getElementById('sdkInfoContent');
                
                if (this.isConnected) {
                    statusEl.style.display = 'flex';
                    statusEl.innerHTML = `
                        <div class="status-dot"></div>
                        <span>Connected to Flywheel - ${this.extension.container.container_type}: ${this.extension.container.label || 'Unknown'}</span>
                    `;
                    
                    // Show correct SDK method info
                    sdkInfoEl.style.display = 'block';
                    sdkInfoContent.innerHTML = `
                        <ul>
                            <li><strong>Upload Method:</strong> Files uploaded directly to current ${this.extension.container.container_type} using extension.uploadFile()</li>
                            <li><strong>Hierarchy Storage:</strong> Complete DICOM hierarchy metadata stored using extension.updateContainerInfo()</li>
                            <li><strong>SDK Methods Used:</strong> Only documented methods (getContainer, uploadFile, updateContainerInfo)</li>
                            <li><strong>Container Creation:</strong> Extension SDK doesn't create containers - hierarchy info stored as metadata</li>
                            <li><strong>Future Use:</strong> Stored metadata can be used by other Flywheel tools to create proper hierarchy</li>
                        </ul>
                    `;
                }
            }

            setupEventListeners() {
                const dropzone = document.getElementById('dropzone');
                const fileInput = document.getElementById('fileInput');
                const uploadBtn = document.getElementById('uploadBtn');
                const clearBtn = document.getElementById('clearBtn');
                const validateBtn = document.getElementById('validateBtn');

                // Drag and drop events
                dropzone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropzone.classList.add('dragover');
                });

                dropzone.addEventListener('dragleave', () => {
                    dropzone.classList.remove('dragover');
                });

                dropzone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropzone.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });

                dropzone.addEventListener('click', () => {
                    fileInput.click();
                });

                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                uploadBtn.addEventListener('click', () => {
                    this.uploadToFlywheel();
                });

                clearBtn.addEventListener('click', () => {
                    this.clearAll();
                });

                validateBtn.addEventListener('click', () => {
                    this.validateFiles();
                });
            }

            async handleFiles(files) {
                this.log(`Processing ${files.length} files with DICOM parser...`, 'info');
                document.getElementById('dropzone').classList.add('processing');
                
                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                progressBar.style.display = 'block';

                this.validationResults = { valid: 0, invalid: 0, errors: [] };

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const progress = ((i + 1) / files.length) * 100;
                    progressFill.style.width = `${progress}%`;

                    try {
                        await this.processDICOMFile(file);
                        this.validationResults.valid++;
                    } catch (error) {
                        this.validationResults.invalid++;
                        this.validationResults.errors.push(`${file.name}: ${error.message}`);
                        this.log(`❌ Error processing ${file.name}: ${error.message}`, 'error');
                    }
                }

                document.getElementById('dropzone').classList.remove('processing');
                progressBar.style.display = 'none';
                
                this.updateHierarchyDisplay();
                this.updateStats();
                this.updateUploadButton();
                
                this.log(`Processing complete: ${this.validationResults.valid} valid, ${this.validationResults.invalid} invalid files`, 
                    this.validationResults.invalid > 0 ? 'warning' : 'success');
            }

            async processDICOMFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            const arrayBuffer = e.target.result;
                            const byteArray = new Uint8Array(arrayBuffer);
                            
                            // Parse DICOM file
                            const dataSet = dicomParser.parseDicom(byteArray);
                            
                            // Extract comprehensive metadata
                            const metadata = this.extractDICOMMetadata(dataSet, file);
                            
                            // Validate required fields
                            this.validateDICOMMetadata(metadata);
                            
                            // Organize into hierarchy
                            this.organizeDICOMFile(file, metadata);
                            
                            this.log(`✅ Parsed: ${file.name} - Patient: ${metadata.patientName}, Study: ${metadata.studyDescription}`, 'success');
                            resolve(metadata);
                            
                        } catch (error) {
                            reject(new Error(`DICOM parsing failed: ${error.message}`));
                        }
                    };
                    
                    reader.onerror = () => {
                        reject(new Error('Failed to read file'));
                    };
                    
                    reader.readAsArrayBuffer(file);
                });
            }

            extractDICOMMetadata(dataSet, file) {
                const getString = (tag) => {
                    try {
                        const element = dataSet.elements[tag];
                        return element ? dataSet.string(tag).trim() : '';
                    } catch (e) {
                        return '';
                    }
                };

                const getNumber = (tag) => {
                    try {
                        const element = dataSet.elements[tag];
                        return element ? dataSet.intString(tag) : '';
                    } catch (e) {
                        return '';
                    }
                };

                const getDate = (tag) => {
                    try {
                        const dateStr = getString(tag);
                        if (dateStr && dateStr.length === 8) {
                            return `${dateStr.substring(0,4)}-${dateStr.substring(4,6)}-${dateStr.substring(6,8)}`;
                        }
                        return dateStr;
                    } catch (e) {
                        return '';
                    }
                };

                const getTime = (tag) => {
                    try {
                        const timeStr = getString(tag);
                        if (timeStr && timeStr.length >= 6) {
                            return `${timeStr.substring(0,2)}:${timeStr.substring(2,4)}:${timeStr.substring(4,6)}`;
                        }
                        return timeStr;
                    } catch (e) {
                        return '';
                    }
                };

                return {
                    // Patient Information
                    patientName: getString('x00100010') || 'Unknown Patient',
                    patientId: getString('x00100020') || `Unknown_${Date.now()}`,
                    patientBirthDate: getDate('x00100030'),
                    patientSex: getString('x00100040'),
                    patientAge: getString('x00101010'),
                    
                    // Study Information
                    studyInstanceUID: getString('x0020000d') || `1.2.3.${Date.now()}.1`,
                    studyDate: getDate('x00080020') || new Date().toISOString().split('T')[0],
                    studyTime: getTime('x00080030') || '120000',
                    studyDescription: getString('x00081030') || 'Unknown Study',
                    studyId: getString('x00200010') || '1',
                    accessionNumber: getString('x00080050'),
                    
                    // Series Information
                    seriesInstanceUID: getString('x0020000e') || `1.2.3.${Date.now()}.2`,
                    seriesNumber: getNumber('x00200011') || '1',
                    seriesDescription: getString('x0008103e') || 'Unknown Series',
                    modality: getString('x00080060') || 'UN',
                    seriesDate: getDate('x00080021'),
                    seriesTime: getTime('x00080031'),
                    
                    // Instance Information
                    sopInstanceUID: getString('x00080018') || `1.2.3.${Date.now()}.3`,
                    instanceNumber: getNumber('x00200013') || '1',
                    
                    // Technical Parameters
                    manufacturer: getString('x00080070'),
                    manufacturerModelName: getString('x00081090'),
                    softwareVersions: getString('x00181020'),
                    protocolName: getString('x00181030'),
                    
                    // Image Parameters (if applicable)
                    rows: getNumber('x00280010'),
                    columns: getNumber('x00280011'),
                    pixelSpacing: getString('x00280030'),
                    sliceThickness: getString('x00180050'),
                    
                    // File Information
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: file.type || 'application/dicom'
                };
            }

            validateDICOMMetadata(metadata) {
                const required = ['patientId', 'studyInstanceUID', 'seriesInstanceUID', 'sopInstanceUID'];
                const missing = required.filter(field => !metadata[field]);
                
                if (missing.length > 0) {
                    throw new Error(`Missing required DICOM fields: ${missing.join(', ')}`);
                }
                
                // Additional validation
                if (!metadata.studyDate || metadata.studyDate.length < 8) {
                    throw new Error('Invalid or missing study date');
                }
            }

            organizeDICOMFile(file, metadata) {
                const groupKey = `${metadata.patientId}_${metadata.studyInstanceUID}`;

                if (!this.fileGroups.has(groupKey)) {
                    this.fileGroups.set(groupKey, {
                        subject: {
                            id: metadata.patientId,
                            name: metadata.patientName,
                            birthDate: metadata.patientBirthDate,
                            sex: metadata.patientSex,
                            age: metadata.patientAge
                        },
                        session: {
                            uid: metadata.studyInstanceUID,
                            date: metadata.studyDate,
                            time: metadata.studyTime,
                            description: metadata.studyDescription,
                            id: metadata.studyId,
                            accessionNumber: metadata.accessionNumber
                        },
                        acquisitions: new Map()
                    });
                }

                const group = this.fileGroups.get(groupKey);
                const acquisitionKey = metadata.seriesInstanceUID;

                if (!group.acquisitions.has(acquisitionKey)) {
                    group.acquisitions.set(acquisitionKey, {
                        uid: metadata.seriesInstanceUID,
                        number: metadata.seriesNumber,
                        description: metadata.seriesDescription,
                        modality: metadata.modality,
                        date: metadata.seriesDate,
                        time: metadata.seriesTime,
                        manufacturer: metadata.manufacturer,
                        model: metadata.manufacturerModelName,
                        protocol: metadata.protocolName,
                        files: []
                    });
                }

                group.acquisitions.get(acquisitionKey).files.push({
                    file: file,
                    metadata: metadata
                });

                this.processedFiles.push({ file, metadata });
            }

            updateStats() {
                const stats = this.calculateStats();
                
                document.getElementById('subjectCount').textContent = stats.subjects;
                document.getElementById('sessionCount').textContent = stats.sessions;
                document.getElementById('acquisitionCount').textContent = stats.acquisitions;
                document.getElementById('fileCount').textContent = stats.files;
                
                const statsEl = document.getElementById('hierarchyStats');
                statsEl.style.display = stats.files > 0 ? 'grid' : 'none';
            }

            calculateStats() {
                const stats = {
                    subjects: this.fileGroups.size,
                    sessions: this.fileGroups.size, // One session per study
                    acquisitions: 0,
                    files: 0
                };

                for (const group of this.fileGroups.values()) {
                    stats.acquisitions += group.acquisitions.size;
                    for (const acquisition of group.acquisitions.values()) {
                        stats.files += acquisition.files.length;
                    }
                }

                return stats;
            }

            updateHierarchyDisplay() {
                const treeEl = document.getElementById('hierarchyTree');
                
                if (this.fileGroups.size === 0) {
                    treeEl.innerHTML = '<div class="empty-state">Upload DICOM files to see the organized hierarchy</div>';
                    return;
                }

                let html = '';
                
                for (const [groupKey, group] of this.fileGroups) {
                    const totalFiles = Array.from(group.acquisitions.values())
                        .reduce((sum, acq) => sum + acq.files.length, 0);

                    const subjectExpanded = this.expandedNodes.has(`subject_${groupKey}`);
                    const sessionExpanded = this.expandedNodes.has(`session_${groupKey}`);

                    html += `
                        <div class="tree-level">
                            <div class="tree-node has-files expandable" onclick="organizer.toggleNode('subject_${groupKey}')">
                                <div class="node-header">
                                    <div class="node-title">
                                        <span class="expand-icon ${subjectExpanded ? 'expanded' : ''}">▶</span>
                                        👤 Subject: ${group.subject.name}
                                    </div>
                                    <div class="file-count">${totalFiles} files</div>
                                </div>
                                <div class="node-details">
                                    Patient ID: ${group.subject.id} | 
                                    Sex: ${group.subject.sex || 'Unknown'} | 
                                    Age: ${group.subject.age || 'Unknown'}
                                </div>
                                
                                ${subjectExpanded ? `
                                    <div class="tree-level">
                                        <div class="tree-node has-files expandable" onclick="organizer.toggleNode('session_${groupKey}', event)">
                                            <div class="node-header">
                                                <div class="node-title">
                                                    <span class="expand-icon ${sessionExpanded ? 'expanded' : ''}">▶</span>
                                                    📅 Session: ${group.session.description}
                                                </div>
                                            </div>
                                            <div class="node-details">
                                                Study Date: ${group.session.date} | 
                                                Time: ${group.session.time} |
                                                Accession: ${group.session.accessionNumber || 'N/A'}
                                            </div>
                                            
                                            ${sessionExpanded ? this.renderAcquisitions(group.acquisitions, groupKey) : ''}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }

                treeEl.innerHTML = html;
            }

            renderAcquisitions(acquisitions, groupKey) {
                let html = '';
                
                for (const [key, acquisition] of acquisitions) {
                    const acquisitionExpanded = this.expandedNodes.has(`acquisition_${groupKey}_${key}`);
                    
                    html += `
                        <div class="tree-level">
                            <div class="tree-node has-files expandable" onclick="organizer.toggleNode('acquisition_${groupKey}_${key}', event)">
                                <div class="node-header">
                                    <div class="node-title">
                                        <span class="expand-icon ${acquisitionExpanded ? 'expanded' : ''}">▶</span>
                                        🔬 ${acquisition.modality} - Series ${acquisition.number}
                                    </div>
                                    <div class="file-count">${acquisition.files.length} files</div>
                                </div>
                                <div class="node-details">${acquisition.description}</div>
                                
                                <div class="metadata-grid">
                                    <div class="metadata-item">
                                        <div class="metadata-label">Modality</div>
                                        <div class="metadata-value">${acquisition.modality}</div>
                                    </div>
                                    <div class="metadata-item">
                                        <div class="metadata-label">Manufacturer</div>
                                        <div class="metadata-value">${acquisition.manufacturer || 'Unknown'}</div>
                                    </div>
                                    <div class="metadata-item">
                                        <div class="metadata-label">Protocol</div>
                                        <div class="metadata-value">${acquisition.protocol || 'N/A'}</div>
                                    </div>
                                    <div class="metadata-item">
                                        <div class="metadata-label">Series UID</div>
                                        <div class="metadata-value">${acquisition.uid.substring(0, 20)}...</div>
                                    </div>
                                </div>
                                
                                ${acquisitionExpanded ? `
                                    <ul class="file-list">
                                        ${acquisition.files.map(fileData => `
                                            <li class="file-item">
                                                <div class="file-header">
                                                    <span class="file-name">${fileData.file.name}</span>
                                                    <span class="file-meta">${this.formatFileSize(fileData.file.size)}</span>
                                                </div>
                                                <div class="file-details">
                                                    <span>Instance: ${fileData.metadata.instanceNumber}</span>
                                                    <span>Rows: ${fileData.metadata.rows || 'N/A'}</span>
                                                    <span>Columns: ${fileData.metadata.columns || 'N/A'}</span>
                                                    <span>Thickness: ${fileData.metadata.sliceThickness || 'N/A'}mm</span>
                                                </div>
                                            </li>
                                        `).join('')}
                                    </ul>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }
                
                return html;
            }

            toggleNode(nodeId, event) {
                if (event) {
                    event.stopPropagation();
                }
                
                if (this.expandedNodes.has(nodeId)) {
                    this.expandedNodes.delete(nodeId);
                } else {
                    this.expandedNodes.add(nodeId);
                }
                
                this.updateHierarchyDisplay();
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            async validateFiles() {
                this.log('🔍 Validating DICOM files and connection...', 'info');
                
                if (this.fileGroups.size === 0) {
                    this.log('⚠️ No files to validate', 'warning');
                    return;
                }

                let issues = [];
                let warnings = [];
                
                // Check Flywheel connection using correct SDK methods
                if (!this.isConnected) {
                    issues.push('Not connected to Flywheel instance');
                } else {
                    try {
                        // Use getContainer method to validate connection
                        const container = await this.extension.getContainer(
                            this.extension.container.container_type, 
                            this.extension.container._id
                        );
                        this.log(`✅ Connected to ${container.container_type}: ${container.label}`, 'success');
                        
                    } catch (error) {
                        issues.push(`Flywheel connection issue: ${error.message}`);
                    }
                }

                // Validate file data
                for (const [groupKey, group] of this.fileGroups) {
                    if (!group.subject.id || group.subject.id.includes('Unknown')) {
                        issues.push(`Subject ${groupKey}: Missing or invalid Patient ID`);
                    }
                    
                    if (!group.subject.name || group.subject.name.includes('Unknown')) {
                        warnings.push(`Subject ${groupKey}: Missing or generic Patient Name`);
                    }
                    
                    if (!group.session.uid || !group.session.date) {
                        issues.push(`Session ${groupKey}: Missing Study UID or Date`);
                    }
                    
                    if (group.acquisitions.size === 0) {
                        issues.push(`Session ${groupKey}: No acquisitions found`);
                    }
                    
                    for (const [acqKey, acquisition] of group.acquisitions) {
                        if (!acquisition.uid || !acquisition.modality) {
                            issues.push(`Acquisition ${acqKey}: Missing Series UID or Modality`);
                        }
                        
                        if (acquisition.files.length === 0) {
                            issues.push(`Acquisition ${acqKey}: No files`);
                        }
                    }
                }

                // Report results
                if (issues.length === 0 && warnings.length === 0) {
                    this.log('✅ Validation passed - files ready for upload', 'success');
                    this.log(`📊 Summary: ${this.fileGroups.size} subjects, ${this.calculateStats().acquisitions} acquisitions, ${this.getTotalFileCount()} files`, 'info');
                } else {
                    if (issues.length > 0) {
                        this.log(`❌ Found ${issues.length} critical issues:`, 'error');
                        issues.forEach(issue => this.log(`  ▸ ${issue}`, 'error'));
                    }
                    
                    if (warnings.length > 0) {
                        this.log(`⚠️ Found ${warnings.length} warnings:`, 'warning');
                        warnings.forEach(warning => this.log(`  ▸ ${warning}`, 'warning'));
                    }
                }

                return { issues, warnings };
            }

            updateUploadButton() {
                const uploadBtn = document.getElementById('uploadBtn');
                const validateBtn = document.getElementById('validateBtn');
                const fileCount = this.getTotalFileCount();
                
                if (fileCount === 0) {
                    uploadBtn.disabled = true;
                    uploadBtn.textContent = 'Upload to Flywheel';
                    validateBtn.disabled = true;
                    return;
                }

                validateBtn.disabled = false;
                
                if (this.isConnected) {
                    uploadBtn.innerHTML = `Upload ${fileCount} files with metadata`;
                    uploadBtn.disabled = false;
                } else {
                    uploadBtn.innerHTML = `${fileCount} files ready (Demo mode)`;
                    uploadBtn.disabled = false; // Allow demo mode
                }
            }

            getTotalFileCount() {
                let total = 0;
                for (const group of this.fileGroups.values()) {
                    for (const acquisition of group.acquisitions.values()) {
                        total += acquisition.files.length;
                    }
                }
                return total;
            }

            async uploadToFlywheel() {
                if (!this.isConnected) {
                    this.log('Demo mode: Simulating upload...', 'warning');
                    await this.simulateUpload();
                    return;
                }

                this.log('🚀 Starting upload to Flywheel using correct SDK methods...', 'info');
                const uploadBtn = document.getElementById('uploadBtn');
                const originalText = uploadBtn.textContent;
                uploadBtn.disabled = true;
                uploadBtn.innerHTML = '<span class="loading-spinner"></span> Uploading...';

                const startTime = Date.now();
                let uploadedFiles = 0;
                let failedFiles = 0;
                const totalFiles = this.getTotalFileCount();

                try {
                    // First, store the complete hierarchy metadata in the container
                    await this.storeHierarchyMetadata();
                    
                    // Then upload all files
                    for (const [groupKey, group] of this.fileGroups) {
                        for (const [seriesKey, acquisition] of group.acquisitions) {
                            for (const fileData of acquisition.files) {
                                try {
                                    await this.uploadSingleFile(fileData.file, fileData.metadata);
                                    uploadedFiles++;
                                    this.log(`✅ Uploaded: ${fileData.file.name} (${uploadedFiles}/${totalFiles})`, 'success');
                                } catch (error) {
                                    failedFiles++;
                                    this.log(`❌ Failed: ${fileData.file.name} - ${error.message}`, 'error');
                                }
                            }
                        }
                    }
                    
                    const duration = Math.round((Date.now() - startTime) / 1000);
                    
                    if (failedFiles === 0) {
                        this.log(`✅ Upload complete! ${uploadedFiles} files uploaded in ${duration}s`, 'success');
                        uploadBtn.textContent = '✅ Upload Complete!';
                        uploadBtn.style.background = '#38a169';
                    } else {
                        this.log(`⚠️ Upload finished with errors: ${uploadedFiles} successful, ${failedFiles} failed in ${duration}s`, 'warning');
                        uploadBtn.textContent = `⚠️ ${uploadedFiles}/${totalFiles} Uploaded`;
                        uploadBtn.style.background = '#ed8936';
                        uploadBtn.disabled = false;
                    }
                    
                } catch (error) {
                    const duration = Math.round((Date.now() - startTime) / 1000);
                    this.log(`❌ Upload failed after ${duration}s: ${error.message}`, 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = '🔄 Retry Upload';
                    uploadBtn.style.background = '#e53e3e';
                }
            }

            async storeHierarchyMetadata() {
                try {
                    this.log('📋 Storing complete hierarchy metadata in container...', 'info');
                    
                    // Create comprehensive metadata object
                    const hierarchyMetadata = {
                        dicom_organizer: {
                            version: '2.0',
                            import_timestamp: new Date().toISOString(),
                            total_subjects: this.fileGroups.size,
                            total_files: this.getTotalFileCount(),
                            subjects: {}
                        }
                    };

                    // Add detailed hierarchy for each subject
                    for (const [groupKey, group] of this.fileGroups) {
                        hierarchyMetadata.dicom_organizer.subjects[groupKey] = {
                            patient_info: {
                                patient_id: group.subject.id,
                                patient_name: group.subject.name,
                                patient_sex: group.subject.sex,
                                patient_age: group.subject.age,
                                patient_birth_date: group.subject.birthDate
                            },
                            study_info: {
                                study_instance_uid: group.session.uid,
                                study_date: group.session.date,
                                study_time: group.session.time,
                                study_description: group.session.description,
                                study_id: group.session.id,
                                accession_number: group.session.accessionNumber
                            },
                            series: {}
                        };

                        // Add series information
                        for (const [seriesKey, acquisition] of group.acquisitions) {
                            hierarchyMetadata.dicom_organizer.subjects[groupKey].series[seriesKey] = {
                                series_instance_uid: acquisition.uid,
                                series_number: acquisition.number,
                                series_description: acquisition.description,
                                modality: acquisition.modality,
                                manufacturer: acquisition.manufacturer,
                                protocol_name: acquisition.protocol,
                                file_count: acquisition.files.length,
                                files: acquisition.files.map(f => ({
                                    filename: f.file.name,
                                    sop_instance_uid: f.metadata.sopInstanceUID,
                                    instance_number: f.metadata.instanceNumber,
                                    file_size: f.file.size
                                }))
                            };
                        }
                    }

                    // Store metadata using updateContainerInfo
                    await this.extension.updateContainerInfo(this.extension.container, {
                        set: hierarchyMetadata
                    });
                    
                    this.log('✅ Hierarchy metadata stored successfully', 'success');
                    
                } catch (error) {
                    this.log(`⚠️ Failed to store hierarchy metadata: ${error.message}`, 'warning');
                    // Don't fail upload if metadata storage fails
                }
            }

            async uploadSingleFile(file, metadata) {
                return new Promise((resolve, reject) => {
                    // Use the documented uploadFile method
                    const uploadObservable = this.extension.uploadFile(this.extension.container, file);
                    
                    uploadObservable.subscribe({
                        next: event => {
                            if (event.type === 'progress') {
                                // Progress updates (optional to log)
                            } else if (event.type === 'response') {
                                resolve(event.file);
                            }
                        },
                        error: error => {
                            reject(new Error(`Upload failed: ${error.message}`));
                        }
                    });
                });
            }

            async simulateUpload() {
                const uploadBtn = document.getElementById('uploadBtn');
                uploadBtn.innerHTML = '<span class="loading-spinner"></span> Simulating upload...';
                uploadBtn.disabled = true;

                let fileCount = 0;
                const totalFiles = this.getTotalFileCount();

                this.log('📋 Simulating hierarchy metadata storage...', 'info');
                await new Promise(resolve => setTimeout(resolve, 500));

                for (const [groupKey, group] of this.fileGroups) {
                    this.log(`📁 Processing Subject: ${group.subject.name}`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    for (const [seriesKey, acquisition] of group.acquisitions) {
                        this.log(`🔬 Processing ${acquisition.modality} Series ${acquisition.number}`, 'info');
                        
                        for (const fileData of acquisition.files) {
                            fileCount++;
                            this.log(`📄 Uploading ${fileData.file.name} (${fileCount}/${totalFiles})`, 'success');
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    }
                }

                uploadBtn.textContent = 'Demo Upload Complete!';
                this.log('✅ Demo upload simulation completed', 'success');
                this.log('ℹ️ In real mode, files would be uploaded to current container with full metadata', 'info');
            }

            clearAll() {
                this.fileGroups.clear();
                this.processedFiles = [];
                this.expandedNodes.clear();
                this.validationResults = { valid: 0, invalid: 0, errors: [] };
                
                document.getElementById('fileInput').value = '';
                this.updateHierarchyDisplay();
                this.updateStats();
                this.updateUploadButton();
                this.log('🗑️ Cleared all files and organization', 'warning');
            }

            log(message, type = 'info') {
                const logEl = document.getElementById('statusLog');
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = `[${timestamp}] ${message}`;
                
                logEl.appendChild(entry);
                logEl.scrollTop = logEl.scrollHeight;

                // Keep only last 100 log entries
                while (logEl.children.length > 100) {
                    logEl.removeChild(logEl.firstChild);
                }
            }
        }

        // Initialize the application
        const organizer = new FixedDICOMOrganizer();
    </script>
</body>
</html>
